<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-defaultDoc/Java/JVM" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.7.0">
<title data-rh="true">JVM | INFO.CENTER</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://cnjszzw.github.io/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://cnjszzw.github.io/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://cnjszzw.github.io/docs/defaultDoc/Java/JVM"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="JVM | INFO.CENTER"><meta data-rh="true" name="description" content="JVM"><meta data-rh="true" property="og:description" content="JVM"><link data-rh="true" rel="icon" href="/img/my-logo.svg"><link data-rh="true" rel="canonical" href="https://cnjszzw.github.io/docs/defaultDoc/Java/JVM"><link data-rh="true" rel="alternate" href="https://cnjszzw.github.io/docs/defaultDoc/Java/JVM" hreflang="en"><link data-rh="true" rel="alternate" href="https://cnjszzw.github.io/docs/defaultDoc/Java/JVM" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="INFO.CENTER RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="INFO.CENTER Atom Feed">





<link rel="manifest" href="/manifest.json">
<meta name="theme-color" content="rgb(37, 194, 160)"><link rel="stylesheet" href="/assets/css/styles.e2f28671.css">
<script src="/assets/js/runtime~main.6ddae659.js" defer="defer"></script>
<script src="/assets/js/main.c623e714.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const n=new URLSearchParams(window.location.search).entries();for(var[t,e]of n)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><link rel="preload" as="image" href="/img/my-logo.svg"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/my-logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/my-logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">INFO.CENTER</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/defaultDoc/Intro">文档</a><a class="navbar__item navbar__link" href="/docs/interviewDoc/HR面试指南">面试</a><a class="navbar__item navbar__link" href="/blog">博客</a></div><div class="navbar__items navbar__items--right"><div class="navbarSearchContainer_Bca1"><div class="navbar__search searchBarContainer_NW3z" dir="ltr"><input placeholder="Search" aria-label="Search" class="navbar__search-input searchInput_YFbd" value=""><div class="loadingRing_RJI3 searchBarLoadingRing_YnHq"><div></div><div></div><div></div><div></div></div></div></div><a href="https://cnjszzw.github.io/cv/zh-cn" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">OhMyCV<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><a href="https://github.com/Cnjszzw" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite" aria-pressed="false"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/defaultDoc/Intro">技术文档中心</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/category/算法">算法</a><button aria-label="Expand sidebar category &#x27;算法&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" href="/docs/category/java">Java</a><button aria-label="Collapse sidebar category &#x27;Java&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/defaultDoc/Java/JVM">JVM</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/defaultDoc/Java/动态代理">动态代理</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/defaultDoc/Java/并发编程">并发编程</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/defaultDoc/Java/集合">Java集合</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/category/消息队列">消息队列</a><button aria-label="Expand sidebar category &#x27;消息队列&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/defaultDoc/MyBatis">MyBatis</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/defaultDoc/MySQL">MySQL</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/defaultDoc/Redis">Redis</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/defaultDoc/SpringBoot">SpringBoot</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/defaultDoc/SpringCloud">微服务架构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/defaultDoc/技术文章推荐">技术文章推荐</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/defaultDoc/计算机网络">计算机网络</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/defaultDoc/设计模式">设计模式</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/defaultDoc/领域驱动设计">领域驱动设计</a></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/category/java"><span itemprop="name">Java</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">JVM</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>JVM</h1></header><p>JVM</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="jvm组成">JVM组成<a href="#jvm组成" class="hash-link" aria-label="Direct link to JVM组成" title="Direct link to JVM组成">​</a></h2>
<p><img decoding="async" loading="lazy" alt="image-20241108194811231" src="/assets/images/image-20241108194811231-49c06c47c4495067f4e3562520e6043d.png" width="1740" height="674" class="img_ev3q"></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="1什么是程序计数器">1.什么是程序计数器<a href="#1什么是程序计数器" class="hash-link" aria-label="Direct link to 1.什么是程序计数器" title="Direct link to 1.什么是程序计数器">​</a></h2>
<p>程序计数器是一个线程私有的变量，java程序编译生成class文件后，这个程序计数器记录了当前代码执行到行了，主要是保存的当前字节码指令的行号</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="2介绍一下java内存中的堆">2.介绍一下Java内存中的堆<a href="#2介绍一下java内存中的堆" class="hash-link" aria-label="Direct link to 2.介绍一下Java内存中的堆" title="Direct link to 2.介绍一下Java内存中的堆">​</a></h2>
<p>堆这块主要是内存共享的区域，主要存放的是这种各种对象实例以及各种数组，它里面又分为两块，一块主要是新生代，一块分为老年代，新生代，又分为Edon区，S1区，S2区域，新的对象实例主要是先放在这个Edon区域，然后逐步再转移到这个S1，S2最后带老生代中，当然过程中也有可能被垃圾回收直接。然后还需要补充的额一个就是方法区或者叫永久代，这个东西主要是存放的一些类的信息，一些静态常量等等，jdk1.7的版本，这个方法区或者说永久代是放    在这个堆当中的，但是jdk1.8之后，就被转移到直接内存了，叫做元空间区域，因为放到堆中，如果堆的内存比较小，这个很容易OOM，因为这个可能是不断增长的，但是这个设置太大了，又会占用过多内存。而放到直接内存，这个问题就会小很多。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="3什么是虚拟机栈">3.什么是虚拟机栈<a href="#3什么是虚拟机栈" class="hash-link" aria-label="Direct link to 3.什么是虚拟机栈" title="Direct link to 3.什么是虚拟机栈">​</a></h2>
<p>虚拟机栈就是每个线程私有的空间，主要是记录了该线程的执行状态，里面主要是一个桟的结构，桟里面主要存放的是一些桟帧，每个桟帧存放着当前的一些内存中的信息，比如说变量，返回值等等，每去调用一个方法就会往里面压入一个桟帧，调用结束就去弹出一个桟帧，先进后出，当前执行的叫做本地桟帧。</p>
<p>能。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="6方法内的局部变量是否是线程安全的">6.方法内的局部变量是否是线程安全的？<a href="#6方法内的局部变量是否是线程安全的" class="hash-link" aria-label="Direct link to 6.方法内的局部变量是否是线程安全的？" title="Direct link to 6.方法内的局部变量是否是线程安全的？">​</a></h2>
<p>这个分情况，如果这个局部变量不涉及外部应用，那就是安全的，完全私有的，但是如果涉及到外部的引用，就不是安全的，因为可能有多个线程对这个外部引用进行修改</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="7说一下栈内存溢出的情况">7.说一下栈内存溢出的情况？<a href="#7说一下栈内存溢出的情况" class="hash-link" aria-label="Direct link to 7.说一下栈内存溢出的情况？" title="Direct link to 7.说一下栈内存溢出的情况？">​</a></h2>
<p>造成栈溢出一般有两种情况，第一种就是栈帧本身内存占用过大，这个一般不存在。第二个就是递归过多，比如无限递归，就会报错StackOverFlow内存溢出。</p>
<p><img decoding="async" loading="lazy" alt="image-20241108203248260" src="/assets/images/image-20241108203248260-71c1bf0dbd576a9271252fb1e4623eba.png" width="794" height="416" class="img_ev3q"></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="8能不能解释一下方法区">8.能不能解释一下方法区<a href="#8能不能解释一下方法区" class="hash-link" aria-label="Direct link to 8.能不能解释一下方法区" title="Direct link to 8.能不能解释一下方法区">​</a></h2>
<p>方法区其实也是一个内存共享的一个区域，jdk1.7之前都放在堆里面，1.8之后就都放在这个直接内存里面了，里面是主要分为了这个class、classloader和运行常量池，其中class记录了一个类的结构和各种的字段信息，classloader主要是用来进行类的加载的，而最后的运行时常量池，的话，首先我先来说一下什么是常量池，这个其实就是相当于一张表，这个表格里面记录了每个字段对应的地址，比如这个类的字段的值的地址，运行时常量池就是值运行的时候，会把这个常量池中的符号引用去替换成真实的引用，这样的话就会在运行的时候去找到真实的运行地址。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="9你听说过这个直接内存的概念吗">9.你听说过这个直接内存的概念吗？<a href="#9你听说过这个直接内存的概念吗" class="hash-link" aria-label="Direct link to 9.你听说过这个直接内存的概念吗？" title="Direct link to 9.你听说过这个直接内存的概念吗？">​</a></h2>
<p>直接内存本质上不属于这个JVM的内存，是属于这个虚拟机或者操作系统的内存，一般用于这个NIO操作，这样效率会高很多，因为不需要涉及这个系统内存缓冲区和这个java内存缓冲区之间</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="类加载器">类加载器<a href="#类加载器" class="hash-link" aria-label="Direct link to 类加载器" title="Direct link to 类加载器">​</a></h2>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="1什么是类加载器类加载器有哪些-">1.什么是类加载器，类加载器有哪些 ？<a href="#1什么是类加载器类加载器有哪些-" class="hash-link" aria-label="Direct link to 1.什么是类加载器，类加载器有哪些 ？" title="Direct link to 1.什么是类加载器，类加载器有哪些 ？">​</a></h2>
<p>java程序的运行机制是是这样的，我们写的是java代码，首先需要通过编译，去编译成为一个字节码文件，然后把这个编译过后的字节码文件放到这个JVM虚拟机上，我们的代码才能跑，而这个类加载器就是把这个编译过后的字节码文件进行加载也就是放到这个JVM比如说堆啊，方法区里面的一个机制。一共主要有四种这种类加载器，第一个就是启动类或者核心类，也就是Jre下面的lib包，第二个就是这种扩展类的加载起，加载这个jre下的lib/ext目录中的拓展类，第三种就是用户类的加载起，这个就是一般来取加载我们自己写的程序。第四种就是这个自定义类的加载起，这个会使用相对比较少。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="2什么是双亲委派模型">2.什么是双亲委派模型？<a href="#2什么是双亲委派模型" class="hash-link" aria-label="Direct link to 2.什么是双亲委派模型？" title="Direct link to 2.什么是双亲委派模型？">​</a></h2>
<p>所谓的双亲委派模型就是，我们再去加载一个类额度过程中，首先会去查找他的父亲加载器，查看这个父加载起有没有加载过，如果没有就一直继续找父加载器去判断，如果最后还没有才自己去进行这种类加载的过程。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="3jvm为什么去使用这个双亲委派模型">3.JVM为什么去使用这个双亲委派模型？<a href="#3jvm为什么去使用这个双亲委派模型" class="hash-link" aria-label="Direct link to 3.JVM为什么去使用这个双亲委派模型？" title="Direct link to 3.JVM为什么去使用这个双亲委派模型？">​</a></h2>
<p>有两点原因吧，第一个就是避免类的重复加载，如果父类已经加载了可以去直接用，这样可以节省内存吗。第二个就是去避免核心的类的api被篡改，比如我自己去写了一个String同名类，自己写了一个API，但是如果这个时候去掉用的时候，双亲委派模型就会发现已经加载了，并且判断出这个是你自己写的，不让你改，算是一个安全性上的保障吧。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="4说一下类装载的执行过程比较难太多了难记">4.说一下类装载的执行过程？（比较难，太多了，难记）<a href="#4说一下类装载的执行过程比较难太多了难记" class="hash-link" aria-label="Direct link to 4.说一下类装载的执行过程？（比较难，太多了，难记）" title="Direct link to 4.说一下类装载的执行过程？（比较难，太多了，难记）">​</a></h2>
<p>类加载的过程一共分为了七个阶段，第一个阶段就是加载，这个过程中会把类的class信息加载到这个metaspace元空间和这个堆内存中，第二个阶段就是验证，主要是验证两个方面，第一个方面就是有没有基本的语法层面的错误，第二个就是验证符号引用的地址有没有问题，第三个阶段就是准备阶段，这个阶段中会把这个类变量分配内存并且初始化，其中如果有静态类型的final变量，或者引用对象，这个时候会去直接进行初始化，第四个阶段就是解析，就是把这文件中的符号引用给转换为真实的地址引用。第五个阶段就是初始化阶段，为类中的静态变量和静态代码块赋予初始值，如果有多个就按照前后顺序来，值得一提的是如果有父子关系就去先加载父类。第六个阶段就是使用阶段，比如说调用了类的静态方法或者说直接new了一个类，这种情况就会去进入到使用的阶段，最后就是销毁阶段，JVM开始销毁创建的Class对象。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="垃圾回收">垃圾回收<a href="#垃圾回收" class="hash-link" aria-label="Direct link to 垃圾回收" title="Direct link to 垃圾回收">​</a></h2>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="1对象什么时候可以被垃圾回收器回收">1.对象什么时候可以被垃圾回收器回收？<a href="#1对象什么时候可以被垃圾回收器回收" class="hash-link" aria-label="Direct link to 1.对象什么时候可以被垃圾回收器回收？" title="Direct link to 1.对象什么时候可以被垃圾回收器回收？">​</a></h2>
<p>对象没有被引用了就会被回收，如何判断这个对象有没有被引用，目前有两种判别方式，一种是引用计数器，一种是可达性分析，我首先来说一下这个引用计数器，他的原理是每个对象会有一个计数器，这个对象每次被引用这个计数器就会+1，否则-1 ， 当为0的时候，就代表没有被引用，也就也意味着可以被回收，但是这里面有一个循环引用的问题，就是两个对象之间有相互的引用，即使后续这两个对象不再使用了，但是循环引用仍然会造成双方的计数器+1，所以不太好这种方法。第二种方法就是可达性分析，这个里面有一个GCroots的概念，从GCRoots这个根节点出发，往这个数一样的结构往下去便利，如果可以便利到，就代表这个元素或者对象是有被引用的，反之就没被引用。那么GCRoots都有哪些呢，我理解下里就是线程中的虚拟机栈，本地方法栈，还有常量池中的常量和静态变量等等，这四个可以用作这个GCRoots。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="2jvm的垃圾回收算法说一说">2.JVM的垃圾回收算法说一说？<a href="#2jvm的垃圾回收算法说一说" class="hash-link" aria-label="Direct link to 2.JVM的垃圾回收算法说一说？" title="Direct link to 2.JVM的垃圾回收算法说一说？">​</a></h2>
<p>一共有三种这种垃圾回收算法。第一种就是标记清楚算法，这个算法通过可达性分析，会标基础所有额需要清楚的碎片区域，直接进行清楚。这种算法的特点就是，比较简单，但是会留下比较碎片化的空间，用的比较少。第二种就是标记整理，该算法就是在标记清楚的算法上多了一个整理的步骤，标记清除之后内存不是不连续和碎片的吗，我们会把用到的内存都去整理放到一块，其他的那就都是空闲空间了，这种算法主要是老年代在用，因为老年代相对来说比较稳定，不存在这种大量的移动。第三种就是标记复制算法，这种算法会把这个内存区域分为两块，一块进行垃圾的标记，标记出来之后，直接全部完整连续的复制到另一块内存中去，再把这一块内存清空，这个算法主要是新生代在用，因为，新生代的垃圾回收比较频繁剩余的可能不多，因此比较适合。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="3说一下jvm中的分带回收">3.说一下JVM中的分带回收<a href="#3说一下jvm中的分带回收" class="hash-link" aria-label="Direct link to 3.说一下JVM中的分带回收" title="Direct link to 3.说一下JVM中的分带回收">​</a></h2>
<p>首先JVM中堆主要分为两个区域，一个是老年代，一个是新生代，新生代中又分为三个区域，第一个是Eden区，一个是幸存者区域From，另一个是幸存者区域To，然后垃圾回收的过程是这样子的，首先会去根据Edno区域和From区域做可达性分析，然后存活的，一起放在TO区域，再过一段时间针对Edon和TO做可达性分析，把存活的再复制到From区域，如此往复，如果发相某些对象移动的次数太多了， 有一个阈值，应该是15，就会认为这个对象一直存活，放到老年代区域中，避免内存的频繁复制。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="4minorgcmixedgc-和-fullgc的区别是什么">4.MinorGC、MixedGC 和 FullGC的区别是什么？<a href="#4minorgcmixedgc-和-fullgc的区别是什么" class="hash-link" aria-label="Direct link to 4.MinorGC、MixedGC 和 FullGC的区别是什么？" title="Direct link to 4.MinorGC、MixedGC 和 FullGC的区别是什么？">​</a></h2>
<p>MinorGC也被称为YoungGC，主要是针对这个新生代的,STW的时间较短，MixedGC主要是G1垃圾回收器锁特有的，针对的对象是新生代和老年代的部分区域，FullGC主要是针对这个新生代和老年代一起的，这个STW的时间比较长，尽量要避免。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="5说一下jvm有哪些垃圾回收器">5.说一下JVM有哪些垃圾回收器？<a href="#5说一下jvm有哪些垃圾回收器" class="hash-link" aria-label="Direct link to 5.说一下JVM有哪些垃圾回收器？" title="Direct link to 5.说一下JVM有哪些垃圾回收器？">​</a></h2>
<p>我了解的有这么几种垃圾收集器，第一种是串行的，比如说serial，serialnew，其中前者是利用了标记清除算法，用于老年代，后者是利用了标记复制算法，用于新生代，特点就是，只有一个垃圾回收的线程，进行垃圾回收的时候，会有一个比较长的STW的时间去进行垃圾回收，第二种就是并行的垃圾回收器，比如说这个Parallel 和 ParallelNew垃圾回收去器，他会把垃圾回收用多个线程来同时执行。第三个就是并发的垃圾回收器，比如说这个CMS的垃圾回收器，他首先再进行垃圾回收的时候，会有一个初始标记的过程，这个过程其他线程也会被阻塞，也就是存在这个STW的时间，但是由于他只是初始标记，因此时间非常段，紧接着他会开始并发标记这个一个过程，这个过程中标记的线程和其他的任务线程一起并发执行，不存在这个STW，完成之后再进行一个重新标记，这样就结束了标记的过程，最后再去执行并发的垃圾清理，同样，这个线程可以和其他的线程一起进行。jdk9之后出现了一个更优秀的G1垃圾回收器</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="6详细说一下g1垃圾回收器">6.详细说一下G1垃圾回收器？<a href="#6详细说一下g1垃圾回收器" class="hash-link" aria-label="Direct link to 6.详细说一下G1垃圾回收器？" title="Direct link to 6.详细说一下G1垃圾回收器？">​</a></h2>
<p>G1垃圾回收器的最大特点就是他把内存区域划分为了许多的一个一个小块小区域，每一个区域都可以是Eden区域，也可以是Surrvior幸存者区域，也可以是老年代的区域，并且考虑到了这种小块可能放不想个别特比大的对象，也设计了一个harmongs区域来放这种大的对象。由于采取了这种设计底层也是采取了这种标记复制的算法。然后我再来说一下这个G1垃圾回收器的工作过程，他一共分为三个这个阶段，第一个阶段叫做这个新生代回收，刚开始的时候，这个堆中什么都没有，加入的元素都是先放入这个Edon区域的，然而随着达到阈值，这个阈值我解释一下就是规定的这个Eden区域的大小，一般在5-6左右，超过了，就要去执行这个新生代垃圾回收，利用这个GCRoots进行这个标记，把被标记过的新生代Edon中的存活的放到一个新的Survivor区域中，然后释放这个Edon区域，当然这是第一次，后续第n次的话，如果已经存在了这个Surrvirror区域，他也会堆已经存在的Surrvirror区域进行复制，把存活的放到这个新的Surrviorr区域中，这个来的幸存者区域就去是放掉，这个过程还会进行判断如果某个对象存活时间过长，会直接放到这个老年代区域。当程序和jvm就这么运行一段时间过后，我们会发现这个old区域是越来越大，一旦打到某一个阈值，也就是G1规定的45%，就会执行一个所谓的并发标记的过程，这个时候不会阻断用户线程，而是去一起并发执行，当然这个之后还有一个STW的重新标记，在这个过程中会标记所有区域的这一个垃圾情况。紧接着这个并发标记结束之后，就会执行一个Mixed混垃圾回收的阶段，这个也就是第三阶段，这个时候对于新生代，同样会把Edon和Surrviorr区域，放入到这个新的Surrviorr区域，并且把Surrviorr存活过久的放到新的来年区域，并把原来的Edon和Surrviorr区域进行一个释放，但是同时他也会对这个老年代进行回收，只不过这个是一个局部回收，他会去判断所有的老年代中那些的回收价值是最大的，比方说有一些这个老年代他存活的对象比较少，如果回收，得到的可用内存就比较大，收益比较高，就会去利用这个复制算法，把这个高收益的老年代进行回收，一起集中放到一个新的这个老年代区域中，然后销毁原来的区域。然后这大概是G1的一个工作的整个过程。最后在这个过程中如果还是发现创建对象的过程还是赶不上销毁对象的过程，就会直接引起FullGC。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="7说一下强引用软引用弱引用和虚引用的区别">7.说一下强引用、软引用、弱引用和虚引用的区别？<a href="#7说一下强引用软引用弱引用和虚引用的区别" class="hash-link" aria-label="Direct link to 7.说一下强引用、软引用、弱引用和虚引用的区别？" title="Direct link to 7.说一下强引用、软引用、弱引用和虚引用的区别？">​</a></h2>
<p>强引用就是我们正常去创建一个new一个对象，这个时候GCRoots进行可达性分析会扫描到这些对象，但是不会进行垃圾回收，即使内页不足也只会报错OOM。软引用的引用强度低了一个档次，通过GCRoots扫描到的时候，内存足够的时候不会动他，但是一旦不足，就会直接进行回收，不会OOM，弱引用，强度继续低一个档次，GCRoots一旦发现，无论内存够不够都进行回收，比如ThreadLocal中的线程Key就是这个类型的，最后一个虚引用，他一般会放到一个虚拟引用的队列中去，一旦发现有一个虚引用RenfrenceHandler来去处理，一旦发现这个虚引用所关联的对象她已经被垃圾回收了，但是有可能有一些关联的地方，比如放在直接内存中，他会去控制这些地方内存的释放。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="jvm实践">JVM实践<a href="#jvm实践" class="hash-link" aria-label="Direct link to JVM实践" title="Direct link to JVM实践">​</a></h2>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="1jvm调优的参数可以在那里进行设置">1.JVM调优的参数可以在那里进行设置？<a href="#1jvm调优的参数可以在那里进行设置" class="hash-link" aria-label="Direct link to 1.JVM调优的参数可以在那里进行设置？" title="Direct link to 1.JVM调优的参数可以在那里进行设置？">​</a></h2>
<p>有两种方式，一种是这个war包部署在这个tomcat上，这个一般需要去修改这个catalina.sh文件中的两个参数，一个是XMS和XMX，前者是初始大小，后者是最大的大小。如果是那种SpringBoot项目，直接修改启动的命令，在启动的命令上加上这两个参数就可以了</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="2jvm调优的参数都有哪些">2.JVM调优的参数都有哪些？<a href="#2jvm调优的参数都有哪些" class="hash-link" aria-label="Direct link to 2.JVM调优的参数都有哪些？" title="Direct link to 2.JVM调优的参数都有哪些？">​</a></h2>
<p>JVM的参数有很多，想要优化的话有这个几点吧。第一个点就是堆的大小，这里面有两个参数XMS和XMX，前者是初始的堆分配内存的大小，后者是最大的被分配内存的大小，可以设置成一样的来避免内存的收缩，然后具体大小的设置一般建议设置为内存的1/64到1/4，这个主要是看我们有没有其他的程序再用，这个设置过小，会产生频繁的GC，过程中肯定会有STW的问题，但是太大了的话，发生了GC，往往要花很长时间，也更消耗内存，所以这是一个综合的考虑。第二个就是栈的大小，这个就是每个线程的虚拟机栈，默认的大小一般是1M，我们可以设置成256KB，一般的方法堆栈用不到过大的内存，当然设置过小也会造成stack over flow的错误，要谨慎设置。第三个就是垃圾回收器的选择，像是JDK1.8其实用的还是Parael和ParalNew垃圾回收器，可以选择用这个G1垃圾回收器，还有其他的参数，比如说这个新生代和这个老生代的分配也可以，默认是8：2，其中新生代占2，并且被Eden和幸存者区Surrviorr平分了，这个时候可以适当调大一点，来避免这个频繁的MinorGC，但是也不能过大，否则老生代不够用，FullGC的频率会增加。还有一些其他参数，比如说这个新生代的转换到老生代，有一个复制次数的阈值，默认是15，这个也可以去调整。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="3说一下jvm调优的工具有哪些">3.说一下JVM调优的工具有哪些？<a href="#3说一下jvm调优的工具有哪些" class="hash-link" aria-label="Direct link to 3.说一下JVM调优的工具有哪些？" title="Direct link to 3.说一下JVM调优的工具有哪些？">​</a></h2>
<p>JVM调优用到的工具主要是分为了两块吧，一块就是这个命令行的工具，比如说是这个jps、jstack、jmap等命令，这个第一个命令主要是查看有哪些进程以及对应的pid的，后面的jstack和jmap可以利用jps拿到的pid去进一步查询相关的堆栈信息，第二块就是可视化的这一块，这里面主要可以用jconsole和VIsualVM这两个工具去查看一些线程和堆栈的信息</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="4java内存泄漏的排查思路是什么">4.Java内存泄漏的排查思路是什么？<a href="#4java内存泄漏的排查思路是什么" class="hash-link" aria-label="Direct link to 4.Java内存泄漏的排查思路是什么？" title="Direct link to 4.Java内存泄漏的排查思路是什么？">​</a></h2>
<p>主要的思路，就是要获取内存泄漏导致宕机的dump文件，这个dump文件记录了内存泄漏的时候堆栈的信息以及很详细的报错信息，我们主要去堆这个dump文件定位到代码的错误行数，然后通过阅读上下文来去进行修复。其中这个dump文件如何产生呢，第一种方式就是利用这个jmap命令，但是这个命令必须在jvm没有崩溃的时候才可以用，或者我们可以堆jvm进行配置，增加一个配置，要求在出现OOM的时候自动生成这个dump文件到指定的目录，这样最后再拿这个visualVM的可视化工具去加载这个dump文件进行分析就好了。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="5cpu飙高的排查方案以及思路">5.CPU飙高的排查方案以及思路？<a href="#5cpu飙高的排查方案以及思路" class="hash-link" aria-label="Direct link to 5.CPU飙高的排查方案以及思路？" title="Direct link to 5.CPU飙高的排查方案以及思路？">​</a></h2>
<p>首先我们需要看一下到底什么哪一个进程占用了大量的cpu资源，这个时候可以利用这个top命令，他会默认根据cpu的使用率堆所有的进程进行展示，第二个就是拿到了这个进行，我们需要再去使用ps命令查一下这个进程的情况，他会展示出所有进程线程下的情况，找到哪个占用cpu最高的线程的id，最后利用这个jstack打印所有进程中的线程信息，寻找相关线程的日志和报错信息，定位到代码的行数，最后到相应的代码位置查看上下文，进行问题的排查。</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col"><a href="https://github.com/Cnjszzw/cnjszzw.github.io/tree/master/docs/defaultDoc/Java/JVM.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_JAkA"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/category/java"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Java</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/defaultDoc/Java/动态代理"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">动态代理</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#jvm组成" class="table-of-contents__link toc-highlight">JVM组成</a></li><li><a href="#1什么是程序计数器" class="table-of-contents__link toc-highlight">1.什么是程序计数器</a></li><li><a href="#2介绍一下java内存中的堆" class="table-of-contents__link toc-highlight">2.介绍一下Java内存中的堆</a></li><li><a href="#3什么是虚拟机栈" class="table-of-contents__link toc-highlight">3.什么是虚拟机栈</a></li><li><a href="#6方法内的局部变量是否是线程安全的" class="table-of-contents__link toc-highlight">6.方法内的局部变量是否是线程安全的？</a></li><li><a href="#7说一下栈内存溢出的情况" class="table-of-contents__link toc-highlight">7.说一下栈内存溢出的情况？</a></li><li><a href="#8能不能解释一下方法区" class="table-of-contents__link toc-highlight">8.能不能解释一下方法区</a></li><li><a href="#9你听说过这个直接内存的概念吗" class="table-of-contents__link toc-highlight">9.你听说过这个直接内存的概念吗？</a></li><li><a href="#类加载器" class="table-of-contents__link toc-highlight">类加载器</a></li><li><a href="#1什么是类加载器类加载器有哪些-" class="table-of-contents__link toc-highlight">1.什么是类加载器，类加载器有哪些 ？</a></li><li><a href="#2什么是双亲委派模型" class="table-of-contents__link toc-highlight">2.什么是双亲委派模型？</a></li><li><a href="#3jvm为什么去使用这个双亲委派模型" class="table-of-contents__link toc-highlight">3.JVM为什么去使用这个双亲委派模型？</a></li><li><a href="#4说一下类装载的执行过程比较难太多了难记" class="table-of-contents__link toc-highlight">4.说一下类装载的执行过程？（比较难，太多了，难记）</a></li><li><a href="#垃圾回收" class="table-of-contents__link toc-highlight">垃圾回收</a></li><li><a href="#1对象什么时候可以被垃圾回收器回收" class="table-of-contents__link toc-highlight">1.对象什么时候可以被垃圾回收器回收？</a></li><li><a href="#2jvm的垃圾回收算法说一说" class="table-of-contents__link toc-highlight">2.JVM的垃圾回收算法说一说？</a></li><li><a href="#3说一下jvm中的分带回收" class="table-of-contents__link toc-highlight">3.说一下JVM中的分带回收</a></li><li><a href="#4minorgcmixedgc-和-fullgc的区别是什么" class="table-of-contents__link toc-highlight">4.MinorGC、MixedGC 和 FullGC的区别是什么？</a></li><li><a href="#5说一下jvm有哪些垃圾回收器" class="table-of-contents__link toc-highlight">5.说一下JVM有哪些垃圾回收器？</a></li><li><a href="#6详细说一下g1垃圾回收器" class="table-of-contents__link toc-highlight">6.详细说一下G1垃圾回收器？</a></li><li><a href="#7说一下强引用软引用弱引用和虚引用的区别" class="table-of-contents__link toc-highlight">7.说一下强引用、软引用、弱引用和虚引用的区别？</a></li><li><a href="#jvm实践" class="table-of-contents__link toc-highlight">JVM实践</a></li><li><a href="#1jvm调优的参数可以在那里进行设置" class="table-of-contents__link toc-highlight">1.JVM调优的参数可以在那里进行设置？</a></li><li><a href="#2jvm调优的参数都有哪些" class="table-of-contents__link toc-highlight">2.JVM调优的参数都有哪些？</a></li><li><a href="#3说一下jvm调优的工具有哪些" class="table-of-contents__link toc-highlight">3.说一下JVM调优的工具有哪些？</a></li><li><a href="#4java内存泄漏的排查思路是什么" class="table-of-contents__link toc-highlight">4.Java内存泄漏的排查思路是什么？</a></li><li><a href="#5cpu飙高的排查方案以及思路" class="table-of-contents__link toc-highlight">5.CPU飙高的排查方案以及思路？</a></li></ul></div></div></div></div></main></div></div></div></div>
</body>
</html>